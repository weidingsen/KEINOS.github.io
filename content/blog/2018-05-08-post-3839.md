---
title: PHP でファイルが名前付きパイプか確認する
author: KEINOS
type: post
date: 2018-05-08T12:32:29+00:00
excerpt: |
  |
    対象となるファイルが「名前付きパイプ」であるかを確認するには filetype() 関数を使って確認することができます。
url: /20180508_3839
yuzo_related_post_metabox:
  - 'a:3:{s:17:"yuzo_include_post";s:0:"";s:17:"yuzo_exclude_post";s:0:"";s:21:"yuzo_disabled_related";N;}'
post_views_count:
  - 384
outline_none:
  - 1
categories:
  - PHP
tags:
  - NamedPipe
  - fifo
  - filetype()

---
## TL;DR {#outline__1}

> `filetype()`関数を使って戻り値が &#8216;fifo&#8217; であるか確認する 

    <?php
    $filename= 'pipe';
    if (file_exists($filename) && ('fifo' === filetype($filename))){
        echo $filename, ' is a named pipe file.', PHP_EOL;
    }
    
    

## TS;DR {#outline__2}

### パイプとは {#outline__2_1}

CLI プログラムを扱っていると、シェルなどの操作で「パイプで渡す」などといった表現が多く出て来ます。

これはシェルのコマンドの結果を他のコマンドに渡す場合に使われる表現で、コマンドとしては「`|`」を使います。

例えばディレクトリの一覧を表示する `ls` コマンドの出力結果を、特定の用語で絞り込むために `grep` コマンドをカマすと言った具合です。

具体的な例で言うと、あるディレクトリ内にある大量のファイルから、特定の文字を含むファイル名のみを抽出したい場合などです。以下は、&#8217;/etc/&#8217; ディレクトリ内にあるファイル名もしくはディレクトリ名のうち &#8216;cron&#8217; を含むものを表示する例です。`ls` と `grep` コマンドが `|` でつながっていることを確認してください。

    $ ls /etc | grep cron
    cron.d
    cron.daily
    cron.hourly
    cron.monthly
    cron.weekly
    crontab
    

上記のように、左のコマンドの出力結果を右のコマンドの引数に渡しているのがわかると思います。つまり `|` がパイプ役になっているイメージです。

同様に `$ ls | php sample.php` のようにすると、`ls` コマンドの結果を &#8216;sample.php&#8217; の標準入力に渡すことができます。また、`|` の代わりに `>` や `>>` を使うとファイルに書き込めるので、コマンドの出力結果をログとして保存することができます。

### 名前付きパイプ（FIFO）とは {#outline__2_2}

名前付きパイプは、センサーやストリーミングなどの「データの終わり（ファイルの終端）が見えないもの」を別のアプリやコマンドに渡す場合に使うと便利です。

先ほど、「パイプを使うとコマンドの出力結果をファイルに出力できる」と説明しましたが、逆に言うと「別のアプリからそのファイルを読み込める」ということでもあります。

しかし、センサーなどのダンプ・データのように常にデータを吐き出すタイプの場合、データをファイルに書き込み続けるため、基本的には書き込みを終えないと他のアプリは読み込むことはできません。（書き込み中のファイルでも [`tail -f` コマンド][1]で読むことはできるのですが、本題とそれるため割愛します）

また、ファイルの読み書きには、やはり速度が犠牲になります。先の例の `$ ls | php sample.php` のようにパイプでプログラムに渡し、プログラムの標準入力からデータを受け取ってもいいのですが、プログラムやコマンドが「ファイルの読み込みを前提」として作られている、つまり標準入力や引数からデータを受け取ることを前提としていない場合、一筋縄とは行きません。

そこで、仮想的なファイルを作成し、そこにダンプやストリーミング・データを垂れ流すイメージで保存します。そうすると、他のアプリやコマンドのプログラムから、その仮想的なファイルを読み込むだけで垂れ流されてくるデータを読み込むことができます。どこでもドアと言うか通り抜けフープと言うか、そんなイメージです。

この一見すると普通のファイルに見える「仮想的なファイル」のことを「**名前付きパイプ**」（named pipe）と呼び、ファイルのタイプを FIFO （[**F**irst **I**n **F**irst **O**ut][2]）と表現します。&#8217;FIFO&#8217;、つまり「先入れ先出し」とは、ファイルに最初に保存されたものが、ファイルを開いたときに最初に出てくるという「ところてん」のようなものです。

しかし、プログラムからファイルを読み込む場合、名前付きパイプであっても普通のファイルであっても、読み込む手順はファイルと基本的に変わりません。そのため、「対象のファイルが実は名前付きパイプのファイルでなかった」というケースがあります。（というより、ありました >_<;）

そこで、読み込む**対象となるファイルが名前付きパイプのファイルであるかを確認する**必要があったのですが、`filetype()` 関数の引数にファイル名（パス）を与えると、`fifo`, `char`, `dir`, `block`, `link`, `file`, `socket`, `unknown`のいずれかの文字列が返されて来るので、これにより確認することができるわけです。

## 参考文献 {#outline__3}

  * &#8220;[filetype][3]&#8221; | manual @ PHP.net

 [1]: https://www.google.co.jp/search?q=tail+%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89
 [2]: https://ja.wikipedia.org/wiki/FIFO
 [3]: http://php.net/manual/ja/function.filetype.php